---
title: "C04 Models - Right Whale (Eubalaena glacialis) (second species)" 
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Setup

```{r source_setup, message=FALSE, warning=FALSE}
source("setup.R")
```

# Pre-requisites: Prepare Right Whale Data (C01-C03)

```{r fetch_data}
fetch_obis("Eubalaena glacialis")
```

```{r read_obs}
obs <- read_observations(scientificname = "Eubalaena glacialis")
dim(obs)
```

```{r load_mask}
coast <- read_coastline()
db <- brickman_database() |> filter(scenario == "STATIC", var == "mask")
mask <- read_brickman(db)
```

```{r count_obs}
all_counts <- count(st_drop_geometry(obs), month)
all_counts
```

```{r thin_obs}
thinned_obs <- sapply(month.abb,
               function(mon){ 
                 thin_by_cell(obs |> filter(month == mon), mask)
               }, simplify = FALSE) |>
  dplyr::bind_rows()
```

```{r bias_map}
bias_map <- rasterize_point_density(obs, mask)
```

```{r sample_background}
nback_avg <- mean(all_counts$n) |> round()

obsbkg <- sapply(month.abb,
    function(mon){ 
      sample_background(thinned_obs |> filter(month == mon),
                       bias_map,
                       method = "bias",
                       return_pres = TRUE,
                       n = nback_avg) |>
        mutate(month = mon, .before = 1)
    }, simplify = FALSE) |>
  bind_rows() |>
  mutate(month = factor(month, levels = month.abb))

obsbkg
```

```{r save_model_input}
write_model_input(obsbkg, scientificname = "Eubalaena glacialis", version = "v1")
```

```{r select_covariates}
present <- read_brickman(add = c("depth"))
keep <- filter_collinear(present, method = "cor_caret", cutoff = 0.65)
keep <- c("depth", "month", keep)
keep
```

```{r save_config}
cfg <- list(
  scientificname = "Eubalaena glacialis",
  version = "v1",
  keep = keep
)
write_configuration(cfg)
```

# Load Data

```{r load_data}
cfg <- read_configuration(scientificname = "Eubalaena glacialis", version = "v1")

# Read the model input (points with class labels)
model_input <- read_model_input(scientificname = "Eubalaena glacialis", 
                               version = "v1")

# Read Brickman covariates
present <- read_brickman(add = c("depth", "month"))

# Extract environmental values at each point
extracted <- extract_brickman(present, model_input, form = "wide")

# Combine and prepare final model input
model_input <- model_input |>
  bind_cols(extracted |> select(-any_of(c(".id")))) |>
  dplyr::mutate(
    month = month_as_number(month),
    depth = log10(depth),
    Xbtm = if("Xbtm" %in% names(extracted)) log10(Xbtm) else NULL
  ) |>
  select(all_of(c("class", cfg$keep))) |>
  na.omit()

dim(model_input)
```

# Splitting the data into groups

```{r initial_split}
model_input_split <- spatial_initial_split(model_input, 
                        prop = 1/5,
                        strategy = spatial_block_cv)
model_input_split
```

```{r initial_split_plot}
autoplot(model_input_split)
```

```{r cv_training}
tr_data <- training(model_input_split)
cv_tr_data <- spatial_block_cv(tr_data,
  v = 5,     
  cellsize = grid_cellsize(model_input),
  offset = grid_offset(model_input) + 0.00001
)
autoplot(cv_tr_data)
```

# Build a recipe

```{r recipe}
one_row_of_training_data <- dplyr::slice(tr_data, 1)
rec <- recipe(one_row_of_training_data, formula = class ~ .)
rec
```

```{r recipe_summary}
summary(rec)
```

# Create a workflow

```{r make_workflow}
wflow <- workflow_set(
  preproc = list(default = rec),
  models = list(
      glm = logistic_reg(mode = "classification") |>
        set_engine("glm"),
      
      rf = rand_forest(
          mtry = tune(),
          trees = tune(),
          mode = "classification") |>
        set_engine("ranger", importance = "impurity"),
      
      btree = boost_tree(
          mtry = tune(), 
          trees = tune(), 
          tree_depth = tune(), 
          learn_rate = tune(), 
          loss_reduction = tune(), 
          stop_iter = tune(),
          mode = "classification") |>
        set_engine("xgboost"),
    
      maxent = maxent(
          feature_classes = tune(),
          regularization_multiplier = tune(),
          mode = "classification") |>
        set_engine("maxnet")
  )
)
wflow
```

# Define metrics

```{r metrics}
metrics <- sdm_metric_set(yardstick::accuracy)
metrics
```

# Fit the models

```{r fit, warning=FALSE}
wflow <- wflow |>
  workflow_map("tune_grid",
    resamples = cv_tr_data, 
    grid = 3,
    metrics = metrics, 
    verbose = TRUE)
```

```{r plot_wflow}
autoplot(wflow)
```

# Select best hyperparameters

```{r select_best}
model_fits <- workflowset_selectomatic(wflow, model_input_split,
                                  filename = "Eubalaena_glacialis-v1-model_fits",
                                  path = data_path("models"))
model_fits
```

# Model Diagnostics

## Metrics Table

```{r model_fit_metrics}
model_fit_metrics(model_fits)
```

## Confusion Matrices

```{r model_fit_confmat}
model_fit_confmat(model_fits)
```

## ROC/AUC

```{r model_fit_roc_auc}
model_fit_roc_auc(model_fits)
```

## Variable Importance

```{r model_fit_vip}
model_fit_varimp_plot(model_fits)
```

## Exploring Random Forest

```{r random_forest}
rf <- model_fits |>
  filter(wflow_id == "default_rf")
rf
```

```{r rf_splits}
autoplot(rf$splits[[1]])
```

```{r rf_metrics}
rf$.metrics[[1]]
```

```{r rf_preds}
rf$.predictions[[1]]
```

```{r rf_workflow}
rf$.workflow[[1]]
```

## Partial Dependence Plot

```{r pd_plot}
model_fit_pdp(model_fits, wid = "default_btree", title = "Boosted Tree - Right Whale")
```

# Summary

This analysis built 4 model types (GLM, Random Forest, Boosted Tree, MaxEnt) for predicting Right Whale habitat suitability in the Gulf of Maine.
